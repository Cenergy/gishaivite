import axios from 'axios'
import type { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelTokenSource } from 'axios'

/**
 * API响应数据结构
 */
interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
}

/**
 * 业务错误类，用于区分业务错误和HTTP错误
 */
class BusinessError extends Error {
  code: number
  data?: any

  constructor(message: string, code: number, data?: any) {
    super(message)
    this.name = 'BusinessError'
    this.code = code
    this.data = data
  }
}

// 判断是否为开发环境
const isDev = import.meta.env.DEV

// 默认请求超时时间(ms)
const DEFAULT_TIMEOUT = 10000

// 创建axios实例
const service: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: DEFAULT_TIMEOUT,
  withCredentials: true, // 允许跨域请求携带cookie
})

// 请求队列管理
interface PendingRequest {
  url: string
  cancel: Function
}
const pendingRequests: PendingRequest[] = []

/**
 * 移除请求队列中的请求
 */
const removePendingRequest = (config: AxiosRequestConfig): void => {
  const url = `${config.url}?${JSON.stringify(config.params)}`
  const index = pendingRequests.findIndex(item => item.url === url)
  if (index !== -1) {
    pendingRequests[index].cancel('请求已取消，重复请求')
    pendingRequests.splice(index, 1)
  }
}

/**
 * 添加请求到队列中
 */
const addPendingRequest = (config: AxiosRequestConfig, cancel: Function): void => {
  const url = `${config.url}?${JSON.stringify(config.params)}`
  pendingRequests.push({
    url,
    cancel
  })
}

/**
 * 清空请求队列
 */
export const clearPendingRequests = (): void => {
  pendingRequests.forEach(item => {
    item.cancel('请求已取消，组件卸载')
  })
  pendingRequests.length = 0
}

// 请求缓存管理
interface CacheItem {
  data: any
  expires: number
}
const cacheMap = new Map<string, CacheItem>()

/**
 * 生成缓存键
 */
const generateCacheKey = (config: AxiosRequestConfig): string => {
  const { method, url, params, data } = config
  return `${method}_${url}_${JSON.stringify(params)}_${JSON.stringify(data)}`
}

/**
 * 设置请求缓存
 */
const setCache = (key: string, data: any, maxAge: number): void => {
  const expires = Date.now() + maxAge
  cacheMap.set(key, { data, expires })
}

/**
 * 获取请求缓存
 */
const getCache = (key: string): any | null => {
  const cache = cacheMap.get(key)
  if (!cache) return null
  
  // 检查缓存是否过期
  if (cache.expires < Date.now()) {
    cacheMap.delete(key)
    return null
  }
  
  return cache.data
}

/**
 * 清除所有缓存
 */
export const clearCache = (): void => {
  cacheMap.clear()
}

/**
 * 创建取消令牌
 */
export const createCancelToken = (): CancelTokenSource => {
  return axios.CancelToken.source()
}

/**
 * 判断是否为取消请求的错误
 */
export const isCancel = (error: any): boolean => {
  return axios.isCancel(error)
}

/**
 * 带有重试功能的请求函数
 * @param requestFn 请求函数
 * @param retries 重试次数
 * @param retryDelay 初始重试延迟(ms)
 * @param backoffFactor 退避因子(指数增长)
 */
export const requestWithRetry = async <T>(
  requestFn: () => Promise<T>,
  retries = 3,
  retryDelay = 300,
  backoffFactor = 2
): Promise<T> => {
  try {
    return await requestFn()
  } catch (error) {
    // 如果是取消请求或者已经没有重试次数，则直接抛出错误
    if (isCancel(error) || retries <= 0) {
      throw error
    }

    // 对于某些错误类型不进行重试
    if (error instanceof BusinessError) {
      throw error
    }

    // 对于网络错误或服务器错误(5xx)进行重试
    const axiosError = error as AxiosError
    if (
      !axiosError.response ||
      (axiosError.response && axiosError.response.status >= 500)
    ) {
      // 等待一段时间后重试
      await new Promise(resolve => setTimeout(resolve, retryDelay))
      
      // 使用指数退避策略增加重试延迟
      return requestWithRetry(
        requestFn,
        retries - 1,
        retryDelay * backoffFactor,
        backoffFactor
      )
    }
    
    throw error
  }
}

// 防抖和节流相关
interface DebouncedRequest {
  timer: NodeJS.Timeout | null
  lastExecTime: number
}
const debouncedRequests = new Map<string, DebouncedRequest>()

/**
 * 防抖请求函数 - 在指定时间内多次调用，只执行最后一次
 * @param requestFn 请求函数
 * @param key 请求唯一标识
 * @param wait 等待时间(ms)
 */
export const debounceRequest = <T>(
  requestFn: () => Promise<T>,
  key: string,
  wait = 300
): Promise<T> => {
  return new Promise((resolve, reject) => {
    const debounced = debouncedRequests.get(key) || { timer: null, lastExecTime: 0 }
    
    // 清除之前的定时器
    if (debounced.timer) {
      clearTimeout(debounced.timer)
    }
    
    // 设置新的定时器
    debounced.timer = setTimeout(() => {
      requestFn()
        .then(resolve)
        .catch(reject)
        .finally(() => {
          // 清理定时器
          debounced.timer = null
        })
    }, wait)
    
    debouncedRequests.set(key, debounced)
  })
}

/**
 * 节流请求函数 - 在指定时间内多次调用，按时间间隔执行
 * @param requestFn 请求函数
 * @param key 请求唯一标识
 * @param wait 等待时间(ms)
 */
export const throttleRequest = <T>(
  requestFn: () => Promise<T>,
  key: string,
  wait = 300
): Promise<T> => {
  return new Promise((resolve, reject) => {
    const throttled = debouncedRequests.get(key) || { timer: null, lastExecTime: 0 }
    const now = Date.now()
    const remaining = wait - (now - throttled.lastExecTime)
    
    if (remaining <= 0) {
      // 可以执行请求
      throttled.lastExecTime = now
      requestFn()
        .then(resolve)
        .catch(reject)
    } else {
      // 设置定时器，等待剩余时间后执行
      if (throttled.timer) {
        clearTimeout(throttled.timer)
      }
      
      throttled.timer = setTimeout(() => {
        throttled.lastExecTime = Date.now()
        requestFn()
          .then(resolve)
          .catch(reject)
          .finally(() => {
            // 清理定时器
            throttled.timer = null
          })
      }, remaining)
    }
    
    debouncedRequests.set(key, throttled)
  })
}

/**
 * 设置请求超时
 * @param timeout 超时时间(ms)
 */
export const setTimeout = (timeout: number): AxiosRequestConfig => {
  return { timeout }
}

/**
 * 使用缓存的请求配置
 * @param maxAge 缓存有效期(ms)
 */
export const useCache = (maxAge: number): AxiosRequestConfig => {
  return { headers: { 'X-Use-Cache': 'true' }, maxAge }
}

// 请求拦截器
service.interceptors.request.use(
  (config: AxiosRequestConfig) => {
    // 设置默认请求头
    config.headers = {
      'Content-Type': 'application/json',
      ...config.headers,
    }

    // 添加授权token（如果有）
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    // 安全增强：添加CSRF令牌（如果有）
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
    if (csrfToken) {
      config.headers['X-CSRF-Token'] = csrfToken
    }
    
    // 安全增强：添加内容安全策略相关头
    config.headers['X-Content-Type-Options'] = 'nosniff'
    
    // 处理请求缓存
    if (config.headers['X-Use-Cache'] === 'true' && config.method?.toLowerCase() === 'get') {
      const cacheKey = generateCacheKey(config)
      const cachedData = getCache(cacheKey)
      
      if (cachedData) {
        // 如果有缓存，取消本次请求并返回缓存数据
        const source = createCancelToken()
        config.cancelToken = source.token
        setTimeout(() => {
          source.cancel('使用缓存数据')
        }, 0)
        
        // 在响应拦截器中会处理这个标记
        config.headers['X-Cache-Hit'] = 'true'
        config.headers['X-Cached-Data'] = JSON.stringify(cachedData)
      }
    }
    
    // 处理请求队列（防止重复请求）
    if (config.method?.toLowerCase() === 'get' || config.method?.toLowerCase() === 'post') {
      const source = createCancelToken()
      config.cancelToken = source.token
      
      // 检查是否有重复请求，如果有则取消之前的请求
      removePendingRequest(config)
      
      // 将当前请求添加到队列
      addPendingRequest(config, source.cancel)
    }

    // 开发环境下记录请求日志
    if (isDev) {
      console.log(
        `%c[Request] ${config.method?.toUpperCase()} ${config.url}`,
        'color: #2196F3',
        config
      )
    }

    return config
  },
  (error) => {
    console.error('请求拦截器错误:', error)
    return Promise.reject(error)
  },
)

// 响应拦截器
service.interceptors.response.use(
  (response: AxiosResponse<ApiResponse>) => {
    // 从请求队列中移除已完成的请求
    removePendingRequest(response.config)
    
    // 处理缓存命中的情况
    if (response.config.headers?.['X-Cache-Hit'] === 'true') {
      try {
        const cachedData = JSON.parse(response.config.headers['X-Cached-Data'] as string)
        return Promise.resolve({
          ...response,
          data: cachedData,
          status: 200,
          statusText: 'OK (cached)',
          headers: { ...response.headers, 'X-Cache': 'HIT' }
        })
      } catch (e) {
        console.error('解析缓存数据失败:', e)
      }
    }
    
    // 设置缓存（如果需要）
    if (
      response.config.headers?.['X-Use-Cache'] === 'true' &&
      response.config.method?.toLowerCase() === 'get' &&
      response.status === 200
    ) {
      const cacheKey = generateCacheKey(response.config)
      const maxAge = response.config.maxAge || 60000 // 默认缓存1分钟
      setCache(cacheKey, response.data, maxAge)
    }
    
    // 开发环境下记录响应日志
    if (isDev) {
      console.log(
        `%c[Response] ${response.config.method?.toUpperCase()} ${response.config.url}`,
        'color: #4CAF50',
        response.data
      )
    }

    // 统一处理业务错误
    // 假设code为0或200表示成功，其他为业务错误
    const { data } = response
    if (data && typeof data === 'object' && 'code' in data) {
      if (data.code !== 0 && data.code !== 200) {
        const businessError = new BusinessError(
          data.message || '业务错误',
          data.code,
          data.data
        )
        
        // 开发环境下记录业务错误日志
        if (isDev) {
          console.error(
            `%c[Business Error] ${response.config.url}`,
            'color: #FF9800',
            businessError
          )
        }
        
        return Promise.reject(businessError)
      }
    }
    
    return response
  },
  (error: AxiosError) => {
    // 从请求队列中移除已完成的请求
    if (error.config) {
      removePendingRequest(error.config)
    }
    
    // 如果是取消的请求，不做处理
    if (isCancel(error)) {
      // 如果是因为使用缓存而取消的请求，不需要抛出错误
      if (error.message === '使用缓存数据') {
        return Promise.resolve({
          data: null,
          status: 200,
          statusText: 'OK (cached)',
          headers: { 'X-Cache': 'HIT' },
          config: error.config || {}
        })
      }
      return Promise.reject(error)
    }
    
    // 统一错误处理
    if (error.response) {
      // 服务器返回了错误状态码
      const status = error.response.status
      const errorMsg = error.response.data?.message || error.message

      // 开发环境下记录HTTP错误日志
      if (isDev) {
        console.error(
          `%c[HTTP Error ${status}] ${error.config?.method?.toUpperCase()} ${error.config?.url}`,
          'color: #F44336',
          error.response.data
        )
      }

      switch (status) {
        case 401:
          console.error('未授权，请重新登录')
          // 可以在这里处理登出逻辑
          // store.dispatch('user/logout');
          // 或者跳转到登录页
          // router.push('/login');
          break
        case 403:
          console.error('拒绝访问:', errorMsg)
          break
        case 404:
          console.error('请求的资源不存在:', errorMsg)
          break
        case 500:
        case 502:
        case 503:
        case 504:
          console.error(`服务器错误(${status}):`, errorMsg)
          break
        default:
          console.error(`请求错误(${status}):`, errorMsg)
      }
    } else if (error.request) {
      // 请求已发出但没有收到响应
      console.error('网络错误，请检查您的网络连接:', error.message)
      
      if (isDev) {
        console.error(
          `%c[Network Error] ${error.config?.method?.toUpperCase()} ${error.config?.url}`,
          'color: #F44336',
          error
        )
      }
    } else {
      // 请求配置出错
      console.error('请求配置错误:', error.message)
      
      if (isDev) {
        console.error(
          '%c[Request Config Error]',
          'color: #F44336',
          error
        )
      }
    }

    return Promise.reject(error)
  },
)

export default service
